/* -*- c -*-
 *
 *  This file is part of the XForms library package.
 *
 *  XForms is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation; either version 2.1, or
 *  (at your option) any later version.
 *
 *  XForms is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with XForms.  If not, see <http://www.gnu.org/licenses/>.
 */


#include "private/flvasprintf.h"
#include <string.h>
#include <ctype.h>



static double global_font_scale = 1.0;

/* Default font families */

static const char * default_families[ ] = { "DejaVu Sans Condensed",
                                            "DejaVu Sans Mono",
                                            "DejaVu Serif Condensed",       
                                            "DejaVu Serif" };

/* Default styles */

struct FONT_STYLE {
	int slant;
	int weight;
} default_styles[ ] =
    { { XFT_SLANT_ROMAN,  XFT_WEIGHT_MEDIUM },
      { XFT_SLANT_ROMAN,  XFT_WEIGHT_BOLD   },
      { XFT_SLANT_ITALIC, XFT_WEIGHT_MEDIUM },
      { XFT_SLANT_ITALIC, XFT_WEIGHT_BOLD   }  };


/* List of all fonts */

static FL_FONT * fl_fonts = NULL;
static size_t font_count = 0;

static size_t num_families = sizeof default_families / sizeof *default_families;
static size_t num_styles = sizeof default_styles / sizeof *default_styles;

#define NUM_DEFAULT_FONTS ( num_families * num_styles )


/***************************************
 ***************************************/

void
fli_init_fonts( void )
{
	size_t i, j;

	if ( fl_fonts )
		return;

    fl_fonts = fl_malloc( NUM_DEFAULT_FONTS * sizeof *fl_fonts );

    for ( i = 0; i < num_families; i++ )
        for ( j = 0; j < num_styles; font_count++, j++ )
        {
            fl_fonts[ font_count ].index = font_count;
            fl_fonts[ font_count ].name  = fl_strdup( default_families[ i ] );
		
            fl_fonts[ font_count ].slant  = default_styles[ j ].slant;
            fl_fonts[ font_count ].weight = default_styles[ j ].weight;
            fl_fonts[ font_count ].scale = 1.0;

            fl_fonts[ font_count ].sized_fonts = NULL;
            fl_fonts[ font_count ].size_count = 0;
        }

    flx->textdraw = fl_state[ fl_vmode ].textdraw =
                           XftDrawCreate( flx->display, fl_root,
                                          fl_state[ fl_vmode ].xvinfo->visual,
                                          fl_state[ fl_vmode ].colormap );

    flx->bgdraw = fl_state[ fl_vmode ].bgdraw =
                           XftDrawCreate( flx->display, fl_root,
                                          fl_state[ fl_vmode ].xvinfo->visual,
                                          fl_state[ fl_vmode ].colormap );
}



/***************************************
 * Helper function for searching for a font with a certain index
 ***************************************/

static int
cmp_fnt_index( const void * arg1,
               const void * arg2 )
{
    return ( ( const FL_FONT * ) arg1 )->index ==
                                          ( ( const FL_FONT * ) arg2 )->index;
}


/***************************************
 * Function returns a pointer to the entry in the font list for
 * the given index (most often the style), or NULL on failure
 ***************************************/

FL_FONT *
fl_get_font_from_index( size_t index )
{
    FL_FONT key;

    /* Remove the extra flags for shadow, engrave or emboss */

    index %= FL_SHADOW_STYLE;

    /* Finding the default fonts is simple since they have sequential
       indices, starting at 0 */

    if ( ! fl_fonts )
        return NULL;

	if ( index < NUM_DEFAULT_FONTS )
		return fl_fonts + index;

    /* If no extra fonts are loaded bail out */

    if ( font_count == NUM_DEFAULT_FONTS )
        return NULL;

    /* Fonts are sorted by ascending order of index, so use a binary
       search */

    key.index = index;
    return bsearch( &key, fl_fonts + NUM_DEFAULT_FONTS,
                    font_count - NUM_DEFAULT_FONTS, sizeof key,
                    cmp_fnt_index );
}


/***************************************
 * Sets a global scaling factor applied to all fonts
 ***************************************/

void
fl_set_global_font_scaling_factor( double factor )
{
	if ( factor <= 0 )
	{
		M_warn( "fl_set_global_font_scaling_factor", "Invalid scaling factor" );
		return;
	}

	global_font_scale = factor;
}


/***************************************
 * Sets a scaling factor for a certain font
 ***************************************/

void
fl_set_font_scaling_factor( int    index,
                            double factor )
{
	FL_FONT * f = fl_get_font_from_index( index );

	if ( ! f )
	{
		M_warn( "fl_set_font_scaling_facor", "Invalid font index" );
		return;
	}

	if ( factor <= 0 )
	{
		M_warn( "fl_set_font_scaling_factor", "Invalid scaling factor" );
		return;
	}

	f->scale = factor;
}
	

/***************************************
 * Returns the name of the indexed font
 ***************************************/

const char *
fl_get_font_name( int index )
{
    static char * name = NULL;

	FL_FONT * f = fl_get_font_from_index( index );

    if ( ! f )
        return NULL;

    if ( f->slant == -1 || f->weight == -1 )
    {
        fli_safe_free( name );
        name = fl_strdup( f->name );
    }
    else
    {
        name = fl_realloc( name, strlen( f->name ) + 25 );
        strcpy( name, f->name );

        switch ( f->slant )
        {
            case XFT_SLANT_ROMAN :
                strcat( name, ": Roman, " );
                break;

            case XFT_SLANT_ITALIC :
                strcat( name, ": Italc, " );
                break;

            case XFT_SLANT_OBLIQUE :
                strcat( name, ": Oblique, " );
        }

        switch ( f->weight )
        {
            case XFT_WEIGHT_LIGHT :
                strcat( name, "Light" );
                break;

            case XFT_WEIGHT_MEDIUM :
                strcat( name, "Medium" );
                break;

            case XFT_WEIGHT_DEMIBOLD :
                strcat( name, "Demibold" );
                break;

            case XFT_WEIGHT_BOLD :
                strcat( name, "Bold" );
                break;

            case XFT_WEIGHT_BLACK :
                strcat( name, "Black" );
                break;
        }
    }

	return name;
}


/***************************************
 * ALlows to switch between the use of True and Open Type fonts and
 * the old X11 bitmap fonts as the default fonts
 ***************************************/

void
fl_set_default_font_type( FL_FONT_TYPE type )
{
    size_t i, j;
    const char ** name;

    if ( type == FL_X11_FONT )
        for ( i = 0, name = bitmap_fonts; *name; i++, name++ )
            fl_set_font_name( i, *name );
    else if  ( type == FL_XFT_FONT )
        for ( i = 0; i < num_families; i++ )
            for ( j = 0; j < num_styles; j++ )
                fl_set_xft_font_name( i * num_styles + j,
                                      default_families[ i ],
                                      default_styles[ j ].slant,
                                      default_styles[ j ].weight );
    else
        M_err( "fl_set_default_font_type", "Invalid argument" );

    fl_state[ fl_vmode ].cur_fnt = flx->fs = NULL;
}


/***************************************
 * Add a new X11 bitmap font (with ID 'index') or replace the
 * existing font with that ID.
 ***************************************/

int
fl_set_font_name( int          index,
                  const char * name )
{
	FL_FONT * f;
	char * full_name;

    /* Index can't be arbitrary, otherwise it might conflict with the
       "special" flags for shadow, engraved and embossed */

    if ( index < 0 || index > FL_MAXFONTS )
    {
        M_warn( "fl_set_xft_font_name", "Invalid index" );
        return -1;
    }

	if ( ! name || ! *name )
    {
        M_warn( "fl_set_font_name", "Missing font name" );
        return -1;
    }

    if ( ! flx || ! flx->display )
	{
		M_warn( "fl_set_font_name", "Can't load font before initialization" );
        return 1;
	}

	if ( ! ( full_name = fli_convert_to_full_xlfd( name ) ) )
	{
        M_warn( "fl_set_font_name", "Font '%s' not found", name );
		return -1;
	}

	/* Now that we have a tested name we can either replace an existing
	   font entry or create a new one. */

	if ( ( f = fl_get_font_from_index( index ) ) )
	{
        while ( f->size_count )
			XftFontClose( fl_display, f->sized_fonts[ --f->size_count ].font );

		fli_safe_free( f->sized_fonts );
		f->size_count = 0;
		fli_safe_free( f->name );

		f->name = fl_strdup( full_name );
		f->slant = f->weight = -1;
		f->scale = 1.0;
	}
	else
	{
		fl_fonts = fl_realloc( fl_fonts, ++font_count * sizeof *fl_fonts );

        f = fl_fonts + font_count - 1;

		f->index       = index;
		f->name        = fl_strdup( full_name );
		f->slant       = f->weight = -1;
		f->sized_fonts = NULL;
		f->size_count  = 0;
		f->scale       = 1.0;

        /* Sort the user defined fonts by index to make them easier to find */

		qsort( fl_fonts + NUM_DEFAULT_FONTS, font_count - NUM_DEFAULT_FONTS,
               sizeof *fl_fonts, fli_font_index_compare );
	}

	return 0;
}


/***************************************
 * Add a new X11 font or replace an existing font.
 ***************************************/

int
fl_set_font_name_f( int          index,
                    const char * fmt,
                    ... )
{
    char *buf;
    int ret;

    EXPAND_FORMAT_STRING( buf, fmt );
    ret = fl_set_font_name( index, buf );
    fl_free( buf );
    return ret;
}


/***************************************
 * Add a new True or Open Type font (with ID 'index') or replace the
 * existing font with that ID.
 ***************************************/

int
fl_set_xft_font_name( int              index,
                      const char     * name,
                      FL_FONT_SLANT    slant,
                      FL_FONT_WEIGHT   weight )
{
	FL_FONT *f;

    /* Index can't be arbitrary, otherwise it might conflict with the
       "special" flags for shadow, engraved or embossed */

    if ( index < 0 || index > FL_MAXFONTS )
    {
        M_warn( "fl_set_xft_font_name", "Invalid index" );
        return -1;
    }

	if ( ! name || ! *name )
    {
        M_warn( "fl_set_xft_font_name", "Missing font name" );
        return -1;
    }

	if (    slant != FL_SLANT_ROMAN
		 && slant != FL_SLANT_ITALIC
		 && slant != FL_SLANT_OBLIQUE )
	{
        M_warn( "fl_set_xft_font_name", "Invalid slant for font" );
        return -1;
    }
		
	if (    weight != FL_WEIGHT_LIGHT
		 && weight != FL_WEIGHT_MEDIUM
		 && weight != FL_WEIGHT_DEMIBOLD
		 && weight != FL_WEIGHT_BOLD
		 && weight != FL_WEIGHT_BLACK )
	{
        M_warn( "fl_set_xft_font_name", "Invalid weight for font" );
        return -1;
    }

    if ( ! flx || ! flx->display )
	{
		M_warn( "fl_set_xft_font_name",
                "Can't load font before fl_initialize()" );
        return 1;
	}

	/* Now that we have tested the font as far as possible (actually opening
       it doesn't make sense since it always succeeds) we can either replace
       an existing font entry or create a new one. */

	if ( ( f = fl_get_font_from_index( index ) ) )
	{
        while ( f->size_count )
			XftFontClose( fl_display, f->sized_fonts[ --f->size_count ].font );

		fli_safe_free( f->sized_fonts );
		f->size_count = 0;
		fli_safe_free( f->name );

		f->name   = fl_strdup( name );
		f->slant  = slant;
		f->weight = weight;
        f->scale  = 1.0;
	}
	else
	{
		fl_fonts = fl_realloc( fl_fonts, ++font_count * sizeof *fl_fonts );

        f = fl_fonts + font_count - 1;

		f->index        = index;
		f->name         = fl_strdup( name );
		f->slant        = slant;
		f->weight       = weight;
		f->scale        = 1.0;
		f->sized_fonts  = NULL;
		f->size_count   = 0;

        /* Sort the user defined fonts by index to make them easier to find */

		qsort( fl_fonts + NUM_DEFAULT_FONTS, font_count - NUM_DEFAULT_FONTS,
               sizeof *fl_fonts, fli_font_index_compare );
	}

	return 0;
}


/***************************************
 * Function for unloading a custom loaded font (at all sizes)
 ***************************************/

int
fl_unload_font( int index )
{
    size_t i;
    FL_FONT *f = NULL;

    /* Don't allow removal of one of the default font */

    index %= FL_SHADOW_STYLE;
    if ( index < ( int ) NUM_DEFAULT_FONTS )
        return -1;

    /* Try to find a user defined font with the requested index */

    for ( i = NUM_DEFAULT_FONTS; i < font_count; i++ )
        if ( fl_fonts[ i ].index == ( size_t ) index )
        {
            f = fl_fonts + i;
            break;
        }

    /* Bail out if not found */

    if ( ! f )
        return -1;

    /* Unload all differently sized fonts */

    while ( f->size_count )
    {
        if ( flx->fs == f->sized_fonts[ --f->size_count ].font )
            fl_state[ fl_vmode ].cur_fnt = flx->fs = NULL;
        XftFontClose( fl_display, f->sized_fonts[ f->size_count ].font );
    }

    /* Deallocate memory used for the unloaded fonts */

    fl_free( f->sized_fonts );
    fl_free( f->name );

    /* Get rid of the now unused entry in the array of fonts */

    fli_remove_and_resize( fl_fonts, sizeof *fl_fonts, &font_count, i, 1 );

    return 0;
}
    

/***************************************
 * Function for unloading a custom loaded font of a certain size
 ***************************************/

int
fl_unload_sized_font( int index,
                      int size )
{
    size_t i, j;

    /* Don't allow removal of one of the default font */

    index %= FL_SHADOW_STYLE;
    if ( index < ( int ) NUM_DEFAULT_FONTS )
        return -1;

    /* Try to find the font with the requested index */

    for ( i = NUM_DEFAULT_FONTS; i < font_count; i++ )
        if ( fl_fonts[ i ].index == ( size_t ) index )
            break;

    /* Bail out if not found */

    if ( i == font_count )
        return -1;

    /* Now look for the requested size */

    for ( j = 0; j < fl_fonts[ i ].size_count; j++ )
        if ( fl_fonts[ i ].sized_fonts[ j ].size == size )
            break;

    /* Give up if not found */

    if ( j == fl_fonts[ i ].size_count )
        return -1;

    if ( flx->fs == fl_fonts[ i ].sized_fonts[ j ].font )
        fl_state[ fl_vmode ].cur_fnt = flx->fs = NULL;
        
    XftFontClose( fl_display, fl_fonts[ i ].sized_fonts[ j ].font );

    /* Remove the entry for the now unused entry in the list of sized fonts */

    fli_remove_and_resize( fl_fonts[ i ].sized_fonts,
                           sizeof *fl_fonts[ i ].sized_fonts,
                           &fl_fonts[ i ].size_count, j, 1 );

    return 0;
}        


/***************************************
 * List all default fonts
 ***************************************/

int
fl_enumerate_fonts( void ( * output )( const char *s ),
                    int  shortform )
{
    size_t i;
	int n;

    for ( n = i = 0; output && i < NUM_DEFAULT_FONTS; i++, n++ )
		output( shortform
                ? cv_fname( fl_get_font_name( i ) )
                : fl_get_font_name( i ) );

    return n;
}


/***************************************
 ***************************************/

XftFont *
fl_get_font_struct( int style,
					int size )
{
	FL_FONT *f;
	size_t i;
	size_t cnt;

	/* Style must be non-negative and in the list of indices */

	if ( style < 0 || ! ( f = fl_get_font_from_index( style ) ) )
	{
        if ( fli_no_connection )
            M_info( "fl_get_font_struct", "Invalid style argument" );
        else
            M_warn( "fl_get_font_struct", "Invalid style argument" );

		return NULL;
	}

	/* Size must be positive */

    if ( size <= 0 )
    {
        M_info( "fl_get_font_struct", "Invalid size argument" );
		return NULL;
	}
 
	/* If font is already loaded return it directly */

	for ( i = 0; i < f->size_count; i++ )
		if ( f->sized_fonts[ i ].size == size )
			return f->sized_fonts[ i ].font;

	cnt = f->size_count;

	/* Increase the length of the list for loaded fonts */

	f->sized_fonts = realloc( f->sized_fonts,
							  ( cnt + 1 ) * sizeof *f->sized_fonts );

	/* This is a normal Xft font if its slant (and weight) are non-negative,
	   so load it with XftFontOpen(). Otherwise it's an X11 font and we need
	   to insert the size into the name and load it using XftFontOpenXlfd()
	   (which can fail!) */

	if ( f->slant != -1 && f->weight != -1 )
		f->sized_fonts[ cnt ].font =
			XftFontOpen( fl_display, fl_screen,
						 XFT_FAMILY, XftTypeString, f->name,
						 XFT_SIZE,   XftTypeDouble,
						 global_font_scale * f->scale * size,
						 XFT_SLANT,  XftTypeInteger, f->slant,
						 XFT_WEIGHT, XftTypeInteger, f->weight,
						 NULL );
	else
	{
		char * name = fli_get_fname( f, size );

		f->sized_fonts[ cnt ].font = XftFontOpenXlfd( fl_display, fl_screen,
													  name );

		fl_free( name );

		if ( ! f->sized_fonts[ cnt ].font )
		{
			f->sized_fonts = realloc( f->sized_fonts,
									  cnt * sizeof *f->sized_fonts );
			return NULL;
		}
	}

	f->sized_fonts[ cnt ].size = size;

	return f->sized_fonts[ f->size_count++ ].font;
}


/***************************************
 * Make a certain font the current one.
 ***************************************/

void
fl_set_font( int index,
             int size )
{
	XftFont * f;

    f = fl_get_font_struct( index, size );

	if ( ! f )
	{
		M_warn( "fl_set_font", "Invalid index, using replacement font" );
		f = fl_get_font_struct( index & FL_BOLDITALIC_STYLE, size );
	}

    /* 'cur_font' is always the one in current GC */

    if ( fl_state[ fl_vmode ].cur_fnt == f )
        return;

    fl_state[ fl_vmode ].cur_fnt = flx->fs = f;

    /* Basic font info (no need to send a string, we just want the maximum
       ascent and descent) */

    flx->fheight = f->height;
	flx->fasc    = f->ascent;
	flx->fdesc   = f->descent;
}


/***************************************
 * Returns the width of a string (not containing tabs or newlines) when
 * using a certain font and size
 ***************************************/

int
fl_get_string_width( int          style,
                     int          size,
                     const char * s,
                     int          len )
{
	XftFont * f = fli_get_font_struct( style, size );

	return f ? fli_get_string_width( f, s, len ) : 0;
}


/***************************************
 ***************************************/

int
fl_get_string_widthTAB( int          style,
                        int          size,
                        const char * s,
                        int          len )
{
	XftFont * f = fli_get_font_struct( style, size );

    return f ? fli_get_string_widthTABfs( f, s, len ) : 0;
}


/***************************************
 * Function returns the height of the string, calculated from adding the
 * largest ascent and descent of all its characters in the string, via 'asc'
 * and 'desc' (but which both can be NULL pointers), the maximum ascent
 * and descent.
 ***************************************/

int
fl_get_string_height( int          style,
                      int          size,
                      const char * s      FL_UNUSED_ARG,
                      int          len    FL_UNUSED_ARG,
                      int *        asc,
                      int *        desc )
{
	XftFont * f = fli_get_font_struct( style, size );

	if ( ! f )
		return 0;

    if ( asc )
        *asc = f->ascent;
    if ( desc )
        *desc = f->descent;

    return f->height;
}


/***************************************
 * Returns the width of a string when rendered using the current
 * default font
 ***************************************/

int
fli_get_text_width( const char * str,
                    size_t       len )
{
    return fli_get_string_width( flx->fs, str, len );
}


/***************************************
 * Returns font height and, via 'asc' and 'desc' (but which both can be NULL
 * pointers), the fonts ascent and descent.
 ***************************************/

int
fl_get_char_height( int   style,
                    int   size,
                    int * asc,
                    int * desc )
{
	XftFont * f = fli_get_font_struct( style, size );

	if ( ! f )
		return 0;

    if ( asc )
        *asc = f->ascent;
    if ( desc )
        *desc = f->descent;

    return f->height;
}


/***************************************
 * Function returns the width of the widest character in the requested font
 ***************************************/

int
fl_get_char_width( int style,
                   int size )
{
	XftFont * f = fli_get_font_struct( style, size );

	return f ? f->max_advance_width : 0;
}


/***************************************
 ***************************************/

void
fl_get_string_dimension( int          style,
                         int          size,
                         const char * s,
                         int          len,
                         int *        width,
                         int *        height )
{
    const char *p,
               *q;
    int h,
        maxw = 0,
        maxh = 0;
	XftFont * f = fli_get_font_struct( style, size );

	if ( f )
	{
		h = f->height;
		
		for ( q = s; *q && ( p = strchr( q, '\n' ) ); q = p + 1 )
		{
			maxw = FL_max( maxw,
						   fli_get_string_width( f, q, p - q ) );
			maxh += h;
		}

		maxw = FL_max( maxw, fli_get_string_width( f, q, len - ( q - s ) ) );
		maxh += h;

		*width  = maxw;
		*height = maxh;
	}
	else
	{
		*width  = 0;
		*height = 0;
	}
}


/***************************************
 ***************************************/

static char * tabstop = "aaaaaaa ";
static size_t tabstopNchar = 8;

void
fl_set_tabstop( const char * s )
{
    static int set;

    if ( s )
    {
        if ( set )
            fl_free( tabstop );
        tabstop = fl_strdup( s );
        tabstopNchar = strlen( tabstop );
        set = 1;
    }
}


/***************************************
 ***************************************/

int
fli_get_tabpixels( XftFont * f )
{
	if ( ! f )
	{
		M_warn( "fli_get_tabpixels", "NULL font argument" );
		return 0;
	}

    return fli_get_string_width( f, tabstop, tabstopNchar );
}


/*
 * Local variables:
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
