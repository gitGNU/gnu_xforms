/* -*- c -*-
 *
 *  This file is part of the XForms library package.
 *
 *  XForms is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation; either version 2.1, or
 *  (at your option) any later version.
 *
 *  XForms is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with XForms.  If not, see <http://www.gnu.org/licenses/>.
 */


#include "private/flvasprintf.h"
#include <string.h>
#include <ctype.h>



static double global_font_scale = 1.0;

/* Default font families */

static const char * default_families[ ] = { "DejaVu Sans Condensed",
                                            "DejaVu Sans Mono",
                                            "DejaVu Serif Condensed",       
                                            "DejaVu Serif" };

/* Default styles */

struct FONT_STYLE {
	int slant;
	int weight;
} default_styles[ ] =
    { { XFT_SLANT_ROMAN,  XFT_WEIGHT_MEDIUM },
      { XFT_SLANT_ROMAN,  XFT_WEIGHT_BOLD   },
      { XFT_SLANT_ITALIC, XFT_WEIGHT_MEDIUM },
      { XFT_SLANT_ITALIC, XFT_WEIGHT_BOLD   }  };


/* List of all fonts */

static FL_FONT * fl_fonts = NULL;
static size_t font_count = 0;

static size_t num_families = sizeof default_families / sizeof *default_families;
static size_t num_styles = sizeof default_styles / sizeof *default_styles;

#define NUM_DEFAULT_FONTS ( num_families * num_styles )


/***************************************
 ***************************************/

void
fli_init_fonts( void )
{
	size_t i, j;

	if ( fl_fonts )
		return;

    fl_fonts = fl_malloc( NUM_DEFAULT_FONTS * sizeof *fl_fonts );

    for ( i = 0; i < num_families; i++ )
        for ( j = 0; j < num_styles; font_count++, j++ )
        {
            fl_fonts[ font_count ].index = font_count;
            fl_fonts[ font_count ].name  = fl_strdup( default_families[ i ] );
		
            fl_fonts[ font_count ].slant  = default_styles[ j ].slant;
            fl_fonts[ font_count ].weight = default_styles[ j ].weight;
            fl_fonts[ font_count ].style  = NULL;
            fl_fonts[ font_count ].scale  = 1.0;

            fl_fonts[ font_count ].sized_fonts = NULL;
            fl_fonts[ font_count ].size_count  = 0;

            fl_fonts[ font_count ].is_x11_font = 0;
        }

    flx->textdraw = fl_state[ fl_vmode ].textdraw =
                           XftDrawCreate( flx->display, fl_root,
                                          fl_state[ fl_vmode ].xvinfo->visual,
                                          fl_state[ fl_vmode ].colormap );

    flx->bgdraw = fl_state[ fl_vmode ].bgdraw =
                           XftDrawCreate( flx->display, fl_root,
                                          fl_state[ fl_vmode ].xvinfo->visual,
                                          fl_state[ fl_vmode ].colormap );
}


/***************************************
 * Function returns a pointer to the entry in the font list for
 * the given index (most often the style), or NULL on failure
 ***************************************/

FL_FONT *
fl_get_font_from_index( size_t index )
{
    /* Remove the extra flags for shadow, engrave or emboss */

    index %= FL_SHADOW_STYLE;

    /* Finding the default fonts is simple since they have sequential
       indices, starting at 0 */

    if ( ! fl_fonts )
        return NULL;

	if ( index < NUM_DEFAULT_FONTS )
		return fl_fonts + index;

    /* If no extra fonts are loaded bail out */

    if ( font_count == NUM_DEFAULT_FONTS )
        return NULL;

    /* Check for the font in whatever else has been loaded */

    return fli_find_font_by_index( fl_fonts + NUM_DEFAULT_FONTS,
                                   font_count - NUM_DEFAULT_FONTS, index );
}


/***************************************
 * Sets a global scaling factor applied to all fonts
 ***************************************/

void
fl_set_global_font_scaling_factor( double factor )
{
	if ( factor <= 0 )
	{
		M_warn( "fl_set_global_font_scaling_factor", "Invalid scaling factor" );
		return;
	}

	global_font_scale = factor;
}


/***************************************
 * Sets a scaling factor for a certain font
 ***************************************/

void
fl_set_font_scaling_factor( int    index,
                            double factor )
{
	FL_FONT * f = fl_get_font_from_index( index );

	if ( ! f )
	{
		M_warn( "fl_set_font_scaling_facor", "Invalid font index" );
		return;
	}

	if ( factor <= 0 )
	{
		M_warn( "fl_set_font_scaling_factor", "Invalid scaling factor" );
		return;
	}

	f->scale = factor;
}
	

/***************************************
 * Returns the name of the indexed font
 ***************************************/

const char *
fl_get_font_name( int index )
{
    static char * name = NULL;

	FL_FONT * f = fl_get_font_from_index( index );

    if ( ! f )
        return NULL;

    if ( f->is_x11_font )
    {
        fli_safe_free( name );
        return fl_strdup( f->name );
    }

    if ( f->style == NULL )
    {
        name = fl_realloc( name, strlen( f->name ) + 31 );
        strcpy( name, f->name );

        switch ( f->slant )
        {
            case XFT_SLANT_ITALIC :
                strcat( name, ":slant=Italc" );
                break;

            case XFT_SLANT_OBLIQUE :
                strcat( name, ":slant=Oblique" );
        }

        switch ( f->weight )
        {
            case XFT_WEIGHT_LIGHT :
                strcat( name, ":weight=Light" );
                break;

            case XFT_WEIGHT_DEMIBOLD :
                strcat( name, ":weight=Demibold" );
                break;

            case XFT_WEIGHT_BOLD :
                strcat( name, ":weight=Bold" );
                break;

            case XFT_WEIGHT_BLACK :
                strcat( name, ":weight=Black" );
                break;
        }
    }
    else
    {
        name = fl_realloc( name, strlen( f->name ) + strlen( f->style ) + 8 );
        sprintf( name, "%s:style=%s", f->name, f->style );
    }

	return name;
}


/***************************************
 * ALlows to switch between the use of True and Open Type fonts and
 * the old X11 bitmap fonts as the default fonts
 ***************************************/

void
fl_set_default_font_type( FL_FONT_TYPE type )
{
    size_t i, j;
    const char ** name;

    if ( type == FL_X11_FONT )
        for ( i = 0, name = bitmap_fonts; *name; i++, name++ )
            fl_set_font_name( i, *name );
    else if  ( type == FL_XFT_FONT )
        for ( i = 0; i < num_families; i++ )
            for ( j = 0; j < num_styles; j++ )
                fl_set_xft_font_name( i * num_styles + j,
                                      default_families[ i ],
                                      default_styles[ j ].slant,
                                      default_styles[ j ].weight );
    else
        M_err( "fl_set_default_font_type", "Invalid argument" );

    fl_state[ fl_vmode ].cur_fnt = flx->fs = NULL;
}


/***************************************
 * Add a new X11 bitmap font (with ID 'index') or replace the
 * existing font with that ID.
 ***************************************/

int
fl_set_font_name( int          index,
                  const char * name )
{
	FL_FONT * f;
	char * full_name;

    /* Index can't be arbitrary, otherwise it might conflict with the
       "special" flags for shadow, engraved and embossed */

    if ( index < 0 || index > FL_MAXFONTS )
    {
        M_warn( "fl_set_xft_font_name", "Invalid index" );
        return -1;
    }

	if ( ! name || ! *name )
    {
        M_warn( "fl_set_font_name", "Missing font name" );
        return -1;
    }

    if ( ! flx || ! flx->display )
	{
		M_warn( "fl_set_font_name", "Can't load font before initialization" );
        return 1;
	}

	if ( ! ( full_name = fli_convert_to_full_xlfd( name ) ) )
	{
        M_warn( "fl_set_font_name", "Font '%s' not found", name );
		return -1;
	}

	/* Now that we have a tested name we can either replace an existing
	   font entry or create a new one. */

	if ( ( f = fl_get_font_from_index( index ) ) )
	{
        while ( f->size_count )
			XftFontClose( fl_display, f->sized_fonts[ --f->size_count ].font );

		fli_safe_free( f->sized_fonts );
        fli_safe_free( f->style );
		f->size_count = 0;
		fli_safe_free( f->name );

		f->name        = fl_strdup( full_name );
        f->slant       = FL_SLANT_NONE;
        f->weight      = FL_WEIGHT_NONE;
        f->style       = NULL;
        f->scale       = 1.0;
        f->is_x11_font = 1;

	}
	else
	{
		fl_fonts = fl_realloc( fl_fonts, ++font_count * sizeof *fl_fonts );

        f = fl_fonts + font_count - 1;

		f->index       = index;
		f->name        = fl_strdup( full_name );
        f->slant       = FL_SLANT_NONE;
        f->weight      = FL_WEIGHT_NONE;
        f->style       = NULL;
        f->scale       = 1.0;
        f->is_x11_font = 1;
		f->sized_fonts = NULL;
		f->size_count  = 0;

        /* Sort the user defined fonts by index to allow faster retrieval
           by using bsearch() */

		qsort( fl_fonts + NUM_DEFAULT_FONTS, font_count - NUM_DEFAULT_FONTS,
               sizeof *fl_fonts, fli_font_index_compare );
	}

	return 0;
}


/***************************************
 * Add a new X11 font or replace an existing font.
 ***************************************/

int
fl_set_font_name_f( int          index,
                    const char * fmt,
                    ... )
{
    char *buf;
    int ret;

    EXPAND_FORMAT_STRING( buf, fmt );
    ret = fl_set_font_name( index, buf );
    fl_free( buf );
    return ret;
}


/***************************************
 * Add a new True or Open Type font (with ID 'index') or replace the
 * existing font with that ID.
 ***************************************/

int
fl_set_xft_font_name( int              index,
                      const char     * name,
                      FL_FONT_SLANT    slant,
                      FL_FONT_WEIGHT   weight )
{
	FL_FONT * f;
    char * family = ( char * ) name;
    char * style = NULL;

    /* Index can't be arbitrary, otherwise it might conflict with the
       "special" flags for shadow, engraved or embossed */

    if ( index < 0 || index > FL_MAXFONTS )
    {
        M_warn( "fl_set_xft_font_name", "Invalid index" );
        return -1;
    }

	if ( ! name || ! *name )
    {
        M_warn( "fl_set_xft_font_name", "Missing font name" );
        return -1;
    }

    if ( ! flx || ! flx->display )
    {
        M_warn( "fl_set_xft_font_name",
                "Can't load font before fl_initialize()" );
        return 1;
    }

    if (    slant != FL_SLANT_ROMAN
		 && slant != FL_SLANT_ITALIC
		 && slant != FL_SLANT_OBLIQUE )
        slant = FL_SLANT_NONE;

    if (    weight != FL_WEIGHT_LIGHT
         && weight != FL_WEIGHT_MEDIUM
         && weight != FL_WEIGHT_DEMIBOLD
         && weight != FL_WEIGHT_BOLD
         && weight != FL_WEIGHT_BLACK )
        weight = FL_WEIGHT_NONE;

    if ( strchr( name, ':' ) )
    {
        slant  = FL_SLANT_NONE;
        weight = FL_WEIGHT_NONE;
    }

    /* Open the font at the default size to be able to figure out what we
       will really get */

    fli_try_xft_font( &family, &slant, &weight, &style );

	/* Now that we have all information about the font as we can either replace
       an existing font entry or create a new one. */

	if ( ( f = fl_get_font_from_index( index ) ) )
	{
        while ( f->size_count )
			XftFontClose( fl_display, f->sized_fonts[ --f->size_count ].font );

		fli_safe_free( f->sized_fonts );
        fli_safe_free( f->style );
		f->size_count = 0;
		fli_safe_free( f->name );

        f->name        = family;
        f->slant       = slant;
        f->weight      = weight;
        f->style       = style;
        f->scale       = 1.0;
        f->is_x11_font = 0;
	}
	else
	{
		fl_fonts = fl_realloc( fl_fonts, ++font_count * sizeof *fl_fonts );

        f = fl_fonts + font_count - 1;

		f->index       = index;
		f->sized_fonts = NULL;
        f->style       = style;
		f->size_count  = 0;

        f->name        = family;
        f->slant       = slant;
        f->weight      = weight;
        f->style       = style;
        f->scale       = 1.0;
        f->is_x11_font = 0;

        /* Sort the user defined fonts by index to make them easier to find */

		qsort( fl_fonts + NUM_DEFAULT_FONTS, font_count - NUM_DEFAULT_FONTS,
               sizeof *fl_fonts, fli_font_index_compare );
	}

	return 0;
}


/***************************************
 * Function for unloading a custom loaded font (at all sizes)
 ***************************************/

int
fl_unload_font( int index )
{
    size_t i;
    FL_FONT *f = NULL;

    /* Don't allow removal of one of the default font */

    index %= FL_SHADOW_STYLE;
    if ( index < ( int ) NUM_DEFAULT_FONTS )
        return -1;

    /* Try to find a user defined font with the requested index */

    for ( i = NUM_DEFAULT_FONTS; i < font_count; i++ )
        if ( fl_fonts[ i ].index == ( size_t ) index )
        {
            f = fl_fonts + i;
            break;
        }

    /* Bail out if not found */

    if ( ! f )
        return -1;

    /* Unload all differently sized fonts */

    while ( f->size_count )
    {
        if ( flx->fs == f->sized_fonts[ --f->size_count ].font )
            fl_state[ fl_vmode ].cur_fnt = flx->fs = NULL;
        XftFontClose( fl_display, f->sized_fonts[ f->size_count ].font );
    }

    /* Deallocate memory used for the unloaded fonts */

    fl_free( f->sized_fonts );
    fl_free( f->style );
    fl_free( f->name );

    /* Get rid of the now unused entry in the array of fonts */

    fli_remove_and_resize( fl_fonts, sizeof *fl_fonts, &font_count, i, 1 );

    return 0;
}
    

/***************************************
 * Function for unloading a custom loaded font of a certain size
 ***************************************/

int
fl_unload_sized_font( int index,
                      int size )
{
    FL_FONT * f;
    FL_SIZED_FONT * sf;

    /* Don't allow removal of one of the default font */

    index %= FL_SHADOW_STYLE;
    if ( index < ( int ) NUM_DEFAULT_FONTS )
        return -1;

    /* Try to find the font with the requested index */

    f = fl_get_font_from_index( index );

    /* Bail out if font was not found or it has no sized fonts */

    if ( ! f || f->size_count == 0 )
        return -1;

    /* Now look for the sized font with the requested size, give up if
       not found */

    if (    ! f->size_count
         || ! ( sf = fli_search_sized_fonts( f->sized_fonts,
                                             f->size_count, size ) ) )
        return -1;

    if ( flx->fs == sf->font )
        fl_state[ fl_vmode ].cur_fnt = flx->fs = NULL;
        
    XftFontClose( fl_display, sf->font );

    /* Remove the entry for the now unused entry in the list of sized fonts */

    fli_remove_and_resize( f->sized_fonts, sizeof *f->sized_fonts,
                           &f->size_count, sf - f->sized_fonts, 1 );

    return 0;
}        


/***************************************
 * List all default fonts
 ***************************************/

int
fl_enumerate_fonts( void ( * output )( const char *s ),
                    int  shortform )
{
    size_t i;
	int n;

    for ( n = i = 0; output && i < NUM_DEFAULT_FONTS; i++, n++ )
		output( shortform
                ? cv_fname( fl_get_font_name( i ) )
                : fl_get_font_name( i ) );

    return n;
}


/***************************************
 * Returns the XftFont structure (pointer) for the font with the requested
 * style and size. May return NULL if 'size' is invalid or the font
 * specified by 'style; wasn't loaded.
 ***************************************/

XftFont *
fl_get_font_struct( int style,
					int size )
{
	FL_FONT *f;
    FL_SIZED_FONT *sf;
    XftFont * xf;

	/* Style must be non-negative and in the list of indices */

	if ( size <= 0 || style < 0 || ! ( f = fl_get_font_from_index( style ) ) )
	{
        if ( fli_no_connection )
            M_info( "fl_get_font_struct", "No connection to server" );
        else
            M_warn( "fl_get_font_struct", "Invalid style or size argument" );

		return NULL;
	}

	/* If font is already loaded return it directly */

    if (    f->size_count
         && ( sf = fli_search_sized_fonts( f->sized_fonts,
                                           f->size_count, size ) ) )
        return sf->font;

	/* Increase the length of the list for sized fonts */

	f->sized_fonts = realloc( f->sized_fonts,
							  ( f->size_count + 1 ) * sizeof *f->sized_fonts );

	/* This is a normal Xft font slant and weight are set or only the style,
	   so load it with XftFontOpen(). Otherwise it's an X11 font and we need
	   to insert the size into the name and load it using XftFontOpenXlfd()
	   (which can fail!) */

	if ( ! f->is_x11_font )
    {
        if ( f->style )
            xf = f->sized_fonts[ f->size_count ].font =
                XftFontOpen( fl_display, fl_screen,
                             XFT_FAMILY, XftTypeString, f->name,
                             XFT_SIZE,   XftTypeDouble,
                             global_font_scale * f->scale * size,
                             XFT_STYLE, XftTypeString, f->style,
                             NULL );
        else
            xf = f->sized_fonts[ f->size_count ].font =
                XftFontOpen( fl_display, fl_screen,
                             XFT_FAMILY, XftTypeString, f->name,
                             XFT_SIZE,   XftTypeDouble,
                             global_font_scale * f->scale * size,
                             XFT_SLANT,  XftTypeInteger, f->slant,
                             XFT_WEIGHT, XftTypeInteger, f->weight,
                             NULL );
    }
    else
	{
		char * name = fli_get_fname( f, size );

		xf = f->sized_fonts[ f->size_count ].font =
                               XftFontOpenXlfd( fl_display, fl_screen, name );

		fl_free( name );

		if ( ! xf )
		{
			f->sized_fonts = realloc( f->sized_fonts,
									  f->size_count * sizeof *f->sized_fonts );
			return NULL;
		}
	}

	f->sized_fonts[ f->size_count++ ].size = size;

    /* Sort the fonts by size to allow faster retrieval using bsearch() */

    qsort( f->sized_fonts, f->size_count, sizeof *f->sized_fonts,
           fli_font_size_compare );

	return xf;
}


/***************************************
 * Make a certain font the current one.
 ***************************************/

void
fl_set_font( int index,
             int size )
{
	XftFont * f;

    f = fl_get_font_struct( index, size );

	if ( ! f )
	{
		M_warn( "fl_set_font", "Invalid index, using replacement font" );
		f = fl_get_font_struct( index & FL_BOLDITALIC_STYLE, size );
	}

    /* 'cur_font' is always the one in current GC */

    if ( fl_state[ fl_vmode ].cur_fnt == f )
        return;

    fl_state[ fl_vmode ].cur_fnt = flx->fs = f;

    /* Basic font info (no need to send a string, we just want the maximum
       ascent and descent) */

    flx->fheight = f->height;
	flx->fasc    = f->ascent;
	flx->fdesc   = f->descent;
}


/***************************************
 * Returns the width of a string (not containing tabs or newlines) when
 * using a certain font and size
 ***************************************/

int
fl_get_string_width( int          style,
                     int          size,
                     const char * s,
                     int          len )
{
	XftFont * f = fli_get_font_struct( style, size );

	return f ? fli_get_string_width( f, s, len ) : 0;
}


/***************************************
 ***************************************/

int
fl_get_string_widthTAB( int          style,
                        int          size,
                        const char * s,
                        int          len )
{
	XftFont * f = fli_get_font_struct( style, size );

    return f ? fli_get_string_widthTABfs( f, s, len ) : 0;
}


/***************************************
 * Function returns the height of the string, calculated from adding the
 * largest ascent and descent of all its characters in the string, via 'asc'
 * and 'desc' (but which both can be NULL pointers), the maximum ascent
 * and descent.
 ***************************************/

int
fl_get_string_height( int          style,
                      int          size,
                      const char * s      FL_UNUSED_ARG,
                      int          len    FL_UNUSED_ARG,
                      int *        asc,
                      int *        desc )
{
	XftFont * f = fli_get_font_struct( style, size );

	if ( ! f )
		return 0;

    if ( asc )
        *asc = f->ascent;
    if ( desc )
        *desc = f->descent;

    return f->height;
}


/***************************************
 * Returns the width of a string when rendered using the current
 * default font
 ***************************************/

int
fli_get_text_width( const char * str,
                    size_t       len )
{
    return fli_get_string_width( flx->fs, str, len );
}


/***************************************
 * Returns font height and, via 'asc' and 'desc' (but which both can be NULL
 * pointers), the fonts ascent and descent.
 ***************************************/

int
fl_get_char_height( int   style,
                    int   size,
                    int * asc,
                    int * desc )
{
	XftFont * f = fli_get_font_struct( style, size );

	if ( ! f )
		return 0;

    if ( asc )
        *asc = f->ascent;
    if ( desc )
        *desc = f->descent;

    return f->height;
}


/***************************************
 * Function returns the width of the widest character in the requested font
 ***************************************/

int
fl_get_char_width( int style,
                   int size )
{
	XftFont * f = fli_get_font_struct( style, size );

	return f ? f->max_advance_width : 0;
}


/***************************************
 * Returns the width and height required for drawing a 'len characters
 * of a string (with embedded new-line characters). The string must be
 * terminated by '\0' even if 'len' is smaller than the length of the
 * string. No handling of tab characters is done.
 ***************************************/

void
fl_get_string_dimension( int          style,
                         int          size,
                         const char * s,
                         int          len,
                         int *        width,
                         int *        height )
{
    const char *q = s;
	XftFont * f = fli_get_font_struct( style, size );

    *width  = 0;
    *height = 0;

	if ( ! f || ! s || ! *s || len <= 0 || size <= 0 )
        return;

    do
    {
        const char * p = strchr( q, '\n' );

        if ( ! p || p > s + len )
            p = s + len;

        if ( p - q )
            *width = FL_max( *width,
                             fli_get_string_width( f, q, p - q ) );
        *height += f->height;

        q = p + 1;
    } while ( q < s + len );
}


/***************************************
 * Sets the string that is used for emulating a 'tab' when trying to
 * determine the width of a tab.
 ***************************************/

static char * tabstop = NULL;

void
fl_set_tabstop( const char * s )
{
    fl_free( tabstop );
    tabstop = fl_strdup( s );
}


/***************************************
 * Calculates the width of a 'tab' (emulated by the string 'tabstop').
& Default for that string is "aaaaaaaa" (i.e. 8 a's in a row).
 ***************************************/

int
fli_get_tabpixels( XftFont * f )
{
    static int width = -1;
    static XftFont *prev_f;

	if ( ! f )
	{
		M_warn( "fli_get_tabpixels", "NULL font argument" );
		return 0;
	}

    if ( ! tabstop )
        fl_set_tabstop( "aaaaaaaa" );

    if ( f != prev_f || width == -1 )
    {
        prev_f = f;
        width = fli_get_string_width( f, tabstop, strlen( tabstop ) );
    }

    return width;
}


/*
 * Local variables:
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
