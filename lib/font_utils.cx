/* -*- c -*-
 *
 *  This file is part of the XForms library package.
 *
 *  XForms is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation; either version 2.1, or
 *  (at your option) any later version.
 *
 *  XForms is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with XForms.  If not, see <http://www.gnu.org/licenses/>.
 */



#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "include/forms.h"
#include "flinternal.h"


/***************************************
 * Function called (by qsort) when sorting the list of fonts by index
 ***************************************/

int
fli_font_index_compare( const void * arg1,
						const void * arg2 )
{
	return ( ( FL_FONT * ) arg1 )->index < ( ( FL_FONT * ) arg2 )->index ?
		   -1 : 1;
}


/***************************************
 * Function cakled by bsearch() for comparing fonts by index
 ***************************************/

static int
fli_cmp_fnt_index( const void * arg1,
				   const void * arg2 )
{
    size_t index1 = ( ( const FL_FONT * ) arg1 )->index;
    size_t index2 = ( ( const FL_FONT * ) arg2 )->index;

	return index1 < index2 ? -1 : ( index1 == index2 ? 0 : 1 );
}


/***************************************
 * Helper function for searching for a font with a certain index
 ***************************************/

FL_FONT *
fli_find_font_by_index( FL_FONT * base,
						size_t    cnt,
						size_t    index )
{
    FL_FONT key;

	key.index = index;
    return bsearch( &key, base, cnt, sizeof key, fli_cmp_fnt_index );
}


/***************************************
 * Function called (by qsort) when sorting a list of sized fonts by size
 ***************************************/

int
fli_font_size_compare( const void * arg1,
					   const void * arg2 )
{
	return ( ( FL_SIZED_FONT * ) arg1 )->size <
		                                 ( ( FL_SIZED_FONT * ) arg2 )->size ?
		   -1 : 1;
}


/***************************************
 * Function called by bsearch() when searching for a sized font of 
 * a certain size
 ***************************************/

static int
fli_cmp_fnt_size( const void * arg1,
				  const void * arg2 )
{
    size_t size1 = ( ( const FL_SIZED_FONT * ) arg1 )->size;
    size_t size2 = ( ( const FL_SIZED_FONT * ) arg2 )->size;

	return size1 < size2 ? -1 : ( size1 == size2 ? 0 : 1 );
}


/***************************************
 * Helper function for searching for a sized font with a certain size
 ***************************************/

FL_SIZED_FONT *
fli_search_sized_fonts( FL_SIZED_FONT * base,
						size_t          cnt,
						int             size )
{
	FL_SIZED_FONT key;

    key.size = size;
    return bsearch( &key, base, cnt, sizeof key, fli_cmp_fnt_size );
}


/***************************************
 * Tries to convert a (possibly shortend) XLFD name or an alias name to
 * the full name (which is needed by XftFontOpenXlfd()), hopefully the
 * one tat would be loaded by XFontLoad(), and returns an allocated
 * string with the full name on success, otherwise a NULL pointer. The
 * font name has the pixel field set to '*' and the 10th of points
 * field to '?'.
 ***************************************/

char *
fli_convert_to_full_xlfd( const char * pattern )
{
	int i;
	int available = 0;
	char ** list;
	static char * result = NULL;
	XFontStruct * xfs;
	XftFont *font;
	char *qm;
	char * sp,
		 * sp2;
	int cnt = 0;
	char * value = NULL;

	fli_safe_free( result );

	/* Get the first fitting font for the pattern */

	if (    ! ( list = XListFonts( fl_display, pattern, 1, &available ) )
		 || available == 0 )
		return NULL;

	/* Now try to get the "real" name of the font, Xft doesn't like
	   alialises etc. */

	if ( ! ( xfs = XLoadQueryFont( fl_display, list[ 0 ] ) ) )
		return NULL;

	for ( i = 0; ! value && i < xfs->n_properties; i++ )
	{

		char * atom = XGetAtomName( fl_display,
									xfs->properties[ i ].name );

		if ( ! strcmp( "FONT", atom ) )
			value = XGetAtomName( fl_display,
								  xfs->properties[ i ].card32 );


		XFree( atom );
	}

	if ( value )
	{
		result = fl_strdup( value );
		XFree( value );
	}

	XFreeFont( fl_display, xfs );

	if ( list )
		XFreeFontNames( list );

	/* Bail out if there was no fitting font name */

	if ( ! result )
		return NULL;

	/* Now look for the pixel size field in the XLFD name and replace it
	   by a '*', it's the one after the 7th dash */

	sp = result;

	while ( cnt < 7 )
		if ( *sp++ == '-' )
			cnt++;

	*sp++ = '*';
	sp2 = sp;
	while ( *sp2 != '-' )
		sp2++;
	if ( sp2 != sp )
		memmove( sp, sp2, strlen( sp2 ) + 1 );

	/* Also replace the following 10th of points field by a '*', but
	   remember its position, we'll replace it by a '?' if the font can
	   be loaded. */

	qm = ++sp;

	*sp++ = '*';
	sp2 = sp;
	while ( *sp2 != '-' )
		sp2++;
	if ( sp2 != sp )
		memmove( sp, sp2, strlen( sp2 ) + 1 );

	/* Also try to load the font using Xft */

	if ( ( font = XftFontOpenXlfd( flx->display, flx->screen, result ) ) )
	{
		XftFontClose( flx->display, font );
		*qm = '?';
	}
	else
		fli_safe_free( result );

	return result;
}


/***************************************
 * Given an XLFD font name (with a '?' at the 10th of a point field) and a
 * size (in points), assemble the complete name with the size inserted
 ***************************************/

char *
fli_get_fname( const FL_FONT * font,
			   int             size )
{
	char * n = fl_malloc( strlen( font->name ) + 20 );
    char *p = strchr( font->name, '?' ) + 1;

	strcpy( n, font->name );
	sprintf( strchr( n, '?' ), "%d",
			 FL_nint( 10 * global_font_scale * font->scale * size ) );
	return strcat( n, p );
}


/***************************************
 * Returns the width of a teh first 'len' characters of string when drawn
 * with font 'f'. The string must be terminated by '\0' even if 'len' is
 * smaller than the length of the string.
 ***************************************/

int
fli_get_string_width( XftFont    * f,
					  const char * s,
					  int          len )
{
	XGlyphInfo extents;

	XftTextExtentsUtf8( fl_display, f, ( XftChar8 * ) s, len, &extents );

    return extents.xOff;
}


/***************************************
 ***************************************/

int
fli_get_string_widthTABfs( XftFont    * f,
                           const char * s,
                           int          len )
{
    int w,
        tab_width;
    const char * q;

    tab_width = fli_get_tabpixels( f );

	w = 0;
	q = s;

	while ( *q == '\t' && q < s + len )
	{
		w += tab_width;
		q++;
	}

	while ( q < s + len )
	{
		const char * p = strchr( q, '\t' );

		if ( ! p || p > s + len )
			p = s + len;

        w += fli_get_string_width( f, q, p - q );

        if ( p == s + len )
            break;

		w = ( ( w / tab_width ) + 1 ) * tab_width;

		q = p + 1;
		
		while ( *q == '\t' && q < s + len )
		{
			w += tab_width;
			q++;
		}
	}

    return w;
}



/***************************************
 ***************************************/

XftFont *
fli_get_font_struct( int style,
					 int size )
{
	XftFont * f= fl_get_font_struct( style, size );

	if ( ! f )
	{
		M_warn( "fli_get_string_width",
				"Invalid index, using replacement font" );
		f = fl_get_font_struct( style & FL_BOLDITALIC_STYLE, size );
	}

	return f;
}


/***************************************
 * Convert X font names to more conventional names by stripping the
 * auxiliary info.
 ***************************************/

char *
fli_cv_fname( const FL_FONT * f )
{
	char * fname = fl_strdup( f->name );
    char *q,
         *p;

    /* Remove all the garbages from head */

    for ( q = fname; *q && ! isalnum( ( unsigned char ) *q ); q++ )
        /* empty */ ;

    /* Remove all the garbage from the end, starting from '?' */

    if ( ( p = strchr( fname, '?' ) ) )
        *--p = '\0';

    /* Remove all remaining garbages */

    for ( p = fname + strlen( fname ) - 1;
          p > q && ! isalnum( ( unsigned char ) *p ); p-- )
        /* empty */ ;

    *++p = '\0';

    return memmove( fname, q, strlen( q ) + 1 );
}


/***************************************
 ***************************************/

void
fli_try_xft_font( char           ** family,
				  FL_FONT_SLANT   * slant,
				  FL_FONT_WEIGHT  * weight,
				  char           ** style )
{
	XftFont * f;
	FcChar8 * fam, *st;


	if ( *slant == FL_SLANT_NONE && *weight == FL_WEIGHT_NONE )
		f = XftFontOpenName( fl_display, fl_screen, *family );
	else
	{
		if ( *weight == FL_WEIGHT_NONE )
			f = XftFontOpen( fl_display, fl_screen,
							 XFT_FAMILY, XftTypeString,  *family,
							 XFT_SLANT,  XftTypeInteger, *slant,
							 NULL );
		else if ( *slant == FL_SLANT_NONE )
			f = XftFontOpen( fl_display, fl_screen,
							 XFT_FAMILY, XftTypeString,  *family,
							 XFT_WEIGHT, XftTypeInteger, *weight,
							 NULL );
		else
			f = XftFontOpen( fl_display, fl_screen,
							 XFT_FAMILY, XftTypeString,  *family,
							 XFT_SLANT,  XftTypeInteger, *slant,
							 XFT_WEIGHT, XftTypeInteger, *weight,
							 NULL );
	}

	if ( FcResultMatch == FcPatternGetString( f->pattern, FC_FAMILY, 0, &fam ) )
		*family = fl_strdup( ( char * ) fam );
	else
		*family = strdup( *family );

	if ( FcResultMatch != FcPatternGetInteger( f->pattern, FC_SLANT, 0, slant ) )
		*slant = FL_SLANT_ROMAN;

	if ( FcResultMatch != FcPatternGetInteger( f->pattern, FC_WEIGHT, 0,
											   weight ) )
		*weight = FL_WEIGHT_MEDIUM;

	if ( FcResultMatch == FcPatternGetString( f->pattern, FC_STYLE, 0, &st ) )
		*style = fl_strdup( ( char * ) st );
	else
		*style = NULL;

	XftFontClose( fl_display, f );
}
